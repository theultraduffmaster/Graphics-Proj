 <!DOCTYPE html>
<html>
  <head>
    <head>
	<meta charset="UTF-8">
	<title>Pong</title>

    <style type="text/css"></style>
  </head>
  <body>
    <script type="text/javascript">
                  
var

/**
 * Constants for the entire game
 */
WIDTH  = 1300, // width of the game
HEIGHT = 550, // height of the game

pi = Math.PI, // pi = 3.14

UpArrow   = 38, //up arrow key equals 38
DownArrow = 40, // down arrow key equals 40

/**
 * reusable game functions
 */
canvas,
ctx,
keystate,

/**
 * The controllable player paddle
 */
player = {
	x: null,
	y: null,

	width:  18, //player paddle width
	height: 90, //player paddle height

	/**
	 * Move as told to by the arrow commands
	 */
	update: function() {
		if (keystate[UpArrow]) this.y -= 7; //this being set to 38
		if (keystate[DownArrow]) this.y += 7; //this being set to 40
		// Ensure the paddle stays inside of the canvas at all times
		this.y = Math.max(Math.min(this.y, HEIGHT - this.height), 0);
	}, //ends update function
    /**
	 * function to draw the player's paddle onto the canvas
	 */
	draw: function() {
		ctx.fillRect(this.x, this.y, this.width, this.height);
        
	}//ends draw function
}, //ends player function

/**
 * The paddle that will be controlled by the ai
 * 
 */
ai = {
	x: null,
	y: null,

	width:  18, //ai paddle width
	height: 90, //ai paddle height

	/**
	 * Reset the ai paddle depending on the position of the ball to optimize the challenge
	 */
	update: function() {
		// function to calculate the ideal position in regards to the ball
		var desty = ball.y - (this.height - ball.side)*0.5;
		// slow the movement towards this ideal position
		this.y += (desty - this.y) * 0.1;
		// Ensure the ai does not leave the canvas
		this.y = Math.max(Math.min(this.y, HEIGHT - this.height), 0);
	}, //ends update function

	/**
	 * Function to draw the ai paddle to the canvas
	 */
	draw: function() {
		ctx.fillRect(this.x, this.y, this.width, this.height);

	} //ends draw function
}, //ends ai function
/**	
 * The tennis ball object
 * 
 */
ball = {
	x:   null,
	y:   null,
	vel: null,
    
    
	side:  10, //size of the ball
	speed: 18, //speed of ball, a more compeitive speed than 16
/**
	 * Serve the ball towards a specified side
	 * 
	 */
	serve: function(side) {
		// set the x and y position of the serve
		var r = Math.random();
		this.x = side===1 ? player.x+player.width : ai.x - this.side;
		this.y = (HEIGHT - this.side)*r;
		/* calculate the angles,  higher/lower on the y-axis = steeper angle i.e. catching the ball on the right or left side of the paddle will give more velocity rather than the center of the paddle
        */
		var phi = 0.1*pi*(1 - 2*r);
		// update the velocity, direction and magnitude
		this.vel = {
			x: side*this.speed*Math.cos(phi),
			y: this.speed*Math.sin(phi)
		} //ends this.vel
	}, //ends serve function

	/**
	 * Update the ball's position and ensure it stays within the canvas
	 */
	update: function() {
		// update the position with new velocity
		this.x += this.vel.x;
		this.y += this.vel.y;
		// check if within the boundaries on the y axis
		if (0 > this.y || this.y+this.side > HEIGHT) {
			// calculate how inside of the canvas the ball is
			var offset = this.vel.y < 0 ? 0 - this.y : HEIGHT - (this.y+this.side);
			this.y += 2*offset;
			// matches the y velocity
			this.vel.y *= -1;
		} //ends if 
		// a function to check intesection between two axis aligned bounding boxes (AABB for short for easyness sake)
		var AABBIntersect = function(ax, ay, aw, ah, bx, by, bw, bh) {
			return ax < bx+bw && ay < by+bh && bx < ax+aw && by < ay+ah;
		}; //ends var AABBIntersect
        // checks against the ai paddle to check collision on the x axis and if the ball should be returned
		var pdle = this.vel.x < 0 ? player : ai;
		if (AABBIntersect(pdle.x, pdle.y, pdle.width, pdle.height,
				this.x, this.y, this.side, this.side)
		) {	
            // sets the x position and calculate the angle of the ball and its trajectory
			this.x = pdle===player ? player.x+player.width : ai.x - this.side;
			var n = (this.y+this.side - pdle.y)/(pdle.height+this.side);
			var phi = 0.25*pi*(2*n - 1); // piÃ·4 = 45
			// calculate the smash (intensity or speed) value and update the velocity accordingly
			var smash = Math.abs(phi) > 0.2*pi ? 1.5 : 1;
			this.vel.x = smash*(pdle===player ? 1 : -1)*this.speed*Math.cos(phi);
			this.vel.y = smash*this.speed*Math.sin(phi);
		} //ends math functions
        
        // resets the ball when it goes off the canvas on the x axis and starts the serve again
		if (0 > this.x+this.side || this.x > WIDTH) {
			this.serve(pdle===player ? 1 : -1);
            
		} //ends if
	}, //ends update function
/**
	 * Draws the tennis ball object to the canvas with its functions
	 */
	draw: function() {
		ctx.fillRect(this.x, this.y, this.side, this.side);
        ctx.fillStyle = "white"; //colors both the paddles of the player and the ai
	} //ends draw
}; //ends ball function
        
        /**
 * Run the game
 */
function main() {
	// create, initiate and edit the game canvas
	canvas = document.createElement("canvas");
	canvas.width = WIDTH;
	canvas.height = HEIGHT;
	ctx = canvas.getContext("2d");
	document.body.appendChild(canvas); //Edits the body to add a child to it

	keystate = {};
	// keep track of the player keyboard presses
	document.addEventListener("keydown", function(evt) {
		keystate[evt.keyCode] = true;
	});
	document.addEventListener("keyup", function(evt) {
		delete keystate[evt.keyCode];
	});
    
    init(); // initiate the game objects

	// allow the game to keep looping
	var loop = function() {
		update();
		draw();

		window.requestAnimationFrame(loop, canvas);
	};
	window.requestAnimationFrame(loop, canvas);
}

    </script>
  </body>
</html>